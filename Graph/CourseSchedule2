class Solution {
    Stack<Integer> ans;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        ans = new Stack<>();

        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adj.add(new ArrayList<>());
        }

        for (int[] course : prerequisites) {
            int prereq = course[1];
            int co = course[0];
            adj.get(prereq).add(co);
        }

        int[] res;
        if (!topo(adj, numCourses)) {
            return new int[0];
        } else {
            res = new int[numCourses];
            int k = 0;
            while(!ans.isEmpty()){
                res[k++] = ans.pop();
            }
        }
        return res;
    }

    public boolean topo(List<List<Integer>> adj, int numCourses) {
        boolean[] visited = new boolean[numCourses];
        boolean[] path = new boolean[numCourses];

        for (int i = 0; i < numCourses; i++) {
            // Only start DFS if not visited
            if (!visited[i]) {
                if (!dfs(adj, visited, path, numCourses, i)) return false;
            }
        }
        return true;
    }

    public boolean dfs(List<List<Integer>> adj, boolean[] visited, boolean[] path,
                       int numCourses, int node) {
        path[node] = true;
        visited[node] = true;

        for (int nei : adj.get(node)) {
            if (!visited[nei]) {
                if (!dfs(adj, visited, path, numCourses, nei)) return false;
            } else if (path[nei]) {
                return false;  // cycle detected
            }
        }

        path[node] = false;
        ans.push(node);
        return true;
    }
}
